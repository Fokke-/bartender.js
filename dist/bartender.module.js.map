{"version":3,"names":[],"mappings":"","sources":["bartender.module.js"],"sourcesContent":["'use strict'\n\n/**\n * Class for creating accessible off-canvas bars.\n */\nclass Bartender {\n\n  /**\n   * @param {object} options - User defined options\n   */\n  constructor (options) {\n    // Polyfill custom events\n    if (typeof window.CustomEvent !== 'function') {\n      window.CustomEvent = function (event, params) {\n        params = params || {\n          bubbles: false,\n          cancelable: false,\n          detail: null,\n        }\n\n        var evt = document.createEvent('CustomEvent')\n        evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail)\n        return evt\n      }\n    }\n\n    // Apply user configuration\n    this.options = Object.assign({\n      // Debug mode\n      debug: false,\n\n      // Show shading overlay over content wrapper when bar is open?\n      overlay: true,\n\n      // Close open bar by clicking the overlay?\n      closeOnOverlayClick: true,\n\n      // Close open bar with escape key?\n      closeOnEsc: true,\n\n      // Trap focus to the open bar?\n      trapFocus: false,\n\n      // Scroll bar to the top when opening it?\n      scrollTop: true,\n\n      // Selector to find main wrapper\n      mainWrapSelector: '.bartender-main',\n\n      // Selector to find content wrapper\n      contentWrapSelector: '.bartender-content',\n\n      // Selector for focusable elements\n      focusableElementSelector: '[href], button, input, textarea, select, details, [tabindex]:not([tabindex=\"-1\"])',\n\n      // Classes\n      readyClass: 'bartender-ready',\n      openClass: 'bartender-open',\n    }, options)\n\n    // Overlay element\n    this.overlay = null\n\n    // Currently open bar\n    this.currentOpenBar = null\n\n    // Button which was previously used to open the bar\n    this.previousOpenButton = null\n\n    // Window resize timeout\n    this.resizeTimeout = null\n\n    // Object for storing the bars\n    this.bars = {}\n\n    // Arrays for storing buttons\n    this.openButtons = []\n    this.closeButtons = []\n    this.toggleButtons = []\n\n    // Array for storing pushable elements\n    // These elements will be moved when bar with \"push\" or \"reveal\" mode is being opened.\n    this.pushElements = []\n\n    // Valid bar positions\n    this.validBarPositions = [\n      'left',\n      'right',\n      'top',\n      'bottom',\n    ]\n\n    // Valid bar modes\n    this.validModes = [\n      'float',\n      'push',\n      'reveal',\n    ]\n\n    // Run initializer\n    this.init()\n  }\n\n  /**\n   * Log to console\n   *\n   * @param {string} text - Text to log\n   * @returns {void}\n   */\n  log (text = '') {\n    console.log('Bartender: ' + text)\n  }\n\n  /**\n   * Log error to console\n   *\n   * @param {string} text - Text to log\n   * @returns {void}\n   */\n  logError (text = '') {\n    console.error('Bartender: ' + text)\n  }\n\n  /**\n   * Log debug message to console\n   *\n   * @param {string} text - Text to log\n   * @returns {void}\n   */\n  debug (text = '') {\n    if (!this.options.debug) return\n\n    console.log('Bartender debug: ' + text)\n  }\n\n  /**\n   * Disable focus on element and it's children\n   *\n   * @param {object} DOM element\n   * @returns {object} DOM element\n   */\n  disableFocus (element) {\n    const startTime = performance.now()\n\n    // Disable focus of element children\n    const children = element.querySelectorAll(this.options.focusableElementSelector)\n\n    for (let i = 0; i < children.length; i++) {\n      children[i].setAttribute('data-bartender-prevtabindex', children[i].getAttribute('tabindex'))\n      children[i].setAttribute('tabindex', '-1')\n    }\n\n    // Disable focus of the element\n    element.setAttribute('tabindex', '-1')\n    element.setAttribute('aria-hidden', 'true')\n\n    const endTime = performance.now()\n    this.debug('Disabled focus of ' + children.length + ' elements in ' + (endTime - startTime))\n\n    return element\n  }\n\n  /**\n   * Enable focus on element and it's children\n   *\n   * @param {object} DOM element\n   * @returns {object} DOM element\n   */\n  enableFocus (element) {\n    const startTime = performance.now()\n\n    // Enable focus of element children\n    const children = element.querySelectorAll('[data-bartender-prevtabindex]')\n\n    for (let i = 0; i < children.length; i++) {\n      // If element has previous tabindex marked, return it. Otherwise just remove tabindex attribute.\n      if (children[i].getAttribute('data-bartender-prevtabindex') != 'null') {\n        children[i].setAttribute('tabindex', children[i].getAttribute('data-bartender-prevtabindex'))\n      } else {\n        children[i].removeAttribute('tabindex')\n      }\n\n      children[i].removeAttribute('data-bartender-prevtabindex')\n    }\n\n    // Enable focus of the element\n    element.setAttribute('tabindex', '0')\n    element.removeAttribute('aria-hidden')\n\n    const endTime = performance.now()\n    this.debug('Enabled focus of ' + children.length + ' elements in ' + (endTime - startTime))\n\n    return element\n  }\n\n  /**\n   * Is defined bar position valid?\n   *\n   * @param {string} position - Position to validate\n   * @returns {boolean}\n   */\n  isValidPosition (position = null) {\n    return this.validBarPositions.indexOf(position) >= 0\n  }\n\n  /**\n   * Initialize Bartender\n   *\n   * @returns {object} Bartender instance\n   */\n  init () {\n    try {\n      // Find and validate required elements\n      this.mainWrap = document.querySelector(this.options.mainWrapSelector)\n      if (!this.mainWrap) throw 'Main wrap element was not found with selector: ' + this.options.mainWrapSelector\n\n      this.contentWrap = this.mainWrap.querySelector(this.options.contentWrapSelector)\n      if (!this.contentWrap) throw 'Content wrap element was not found with selector: ' + this.options.contentWrapSelector\n\n      // Find buttons\n      this.openButtons = this.mainWrap.querySelectorAll('[data-bartender-open]')\n      this.closeButtons = this.mainWrap.querySelectorAll('[data-bartender-close]')\n      this.toggleButtons = this.mainWrap.querySelectorAll('[data-bartender-toggle]')\n\n      // Add classes\n      this.mainWrap.classList.add('bartender-main')\n      this.contentWrap.classList.add('bartender-content')\n\n      // Find bars\n      const bars = this.mainWrap.querySelectorAll('[data-bartender-bar]')\n\n      for (let i = 0; i < bars.length; i++) {\n        this.addBar(bars[i])\n      }\n\n      // Open buttons\n      for (let i = 0; i < this.openButtons.length; i++) {\n        let button = this.openButtons[i]\n        let position = button.getAttribute('data-bartender-open')\n\n        if (!this.isValidPosition(position)) {\n          this.logError('Open button has invalid bar position \\'' + position + '\\' defined. Use one of the following values: ' + this.validBarPositions.join(', '))\n          return\n        }\n\n        button.setAttribute('aria-expanded', 'false')\n        button.addEventListener('click', () => {\n          this.open(position, button)\n        })\n      }\n\n      // Toggle buttons\n      for (let i = 0; i < this.toggleButtons.length; i++) {\n        let button = this.toggleButtons[i]\n        let position = button.getAttribute('data-bartender-toggle')\n\n        if (!this.isValidPosition(position)) {\n          this.logError('Toggle button has invalid bar position \\'' + position + '\\' defined. Use one of the following values: ' + this.validBarPositions.join(', '))\n          return\n        }\n\n        button.setAttribute('aria-expanded', 'false')\n        button.addEventListener('click', () => {\n          this.toggle(position, button)\n        })\n      }\n\n      // Close buttons\n      for (let i = 0; i < this.closeButtons.length; i++) {\n        let button = this.closeButtons[i]\n\n        button.addEventListener('click', () => {\n          this.close()\n        })\n      }\n\n      // Find pushable elements\n      this.pushElements = this.mainWrap.querySelectorAll('[data-bartender-push]')\n\n      if (this.pushElements.length) this.debug('Registered ' + this.pushElements.length + ' pushable elements.')\n\n      // Add overlay\n      if (this.options.overlay && !this.overlay) {\n        this.overlay = document.createElement('div')\n        this.overlay.classList.add('bartender-overlay')\n\n        if (this.options.closeOnOverlayClick === true) {\n          this.overlay.addEventListener('click', () => this.close())\n        }\n\n        this.contentWrap.appendChild(this.overlay)\n      }\n\n      // Enable closing the bar with escape key\n      if (this.options.closeOnEsc) {\n        window.addEventListener('keydown', event => {\n          let key = event.key || event.keyCode\n\n          if (key === 'Escape' || key === 'Esc' || key === 27) {\n            this.close()\n          }\n        })\n      }\n\n      // Adjust content wrapper transform when window is resized\n      window.addEventListener('resize', () => {\n        clearTimeout(this.resizeTimeout)\n\n        this.resizeTimeout = setTimeout(() => {\n          this.setPush()\n        }, 200)\n      })\n\n      // Add class\n      this.mainWrap.classList.add(this.options.readyClass)\n    } catch (error) {\n      this.logError(error)\n    }\n\n    return this\n  }\n\n  /**\n   * Add a new off-canvas bar\n   *\n   * @param {object} element - DOM element. If undefined, the element will be created.\n   * @param {object} options - Bar options\n   * @returns {object} Added bar instance\n   */\n  addBar (element = null, options = {}) {\n    try {\n      // If element doesn't exist, create it\n      let newElement = false\n\n      if (element === null) {\n        newElement = true\n        element = document.createElement('div')\n      }\n\n      // Initially remove transition\n      element.style.transition = 'none'\n\n      // Get bar configuration\n      let position = options.position || element.getAttribute('data-bartender-bar')\n      let mode = options.mode || element.getAttribute('data-bartender-bar-mode')\n\n      // If mode is not specified, fall back to 'float'\n      mode = mode || 'float'\n\n      // Validate configuration\n      if (!this.isValidPosition(position)) throw 'Invalid bar position \\'' + position + '\\'. Use one of the following values: ' + this.validBarPositions.join(', ')\n      if (this.validModes.indexOf(mode) < 0) throw 'Invalid mode \\'' + mode + '\\' for bar \\'' + position + '\\'. Use one of the following values: ' + this.validModes.join(', ')\n      if (this.bars[position]) throw 'Bar with position \\'' + position + '\\' is already defined'\n\n      // Set data-attributes\n      element.setAttribute('data-bartender-bar', position)\n      element.setAttribute('data-bartender-bar-mode', mode)\n\n      // If element is new, append to main container\n      if (newElement === true) this.mainWrap.appendChild(element)\n\n      // Return transition\n      setTimeout(() => {\n        element.style.transition = null\n      })\n\n      // Create new bar object\n      const newBar = {\n        element: element,\n        position: position,\n        mode: mode,\n      }\n\n      this.bars[position] = newBar\n\n      // Initially disable focus of the bar\n      this.disableFocus(newBar.element)\n\n      this.debug('Added bar \\'' + position + '\\' with mode \\'' + mode + '\\'')\n\n      return newBar\n    } catch (error) {\n      this.logError(error)\n\n      return null\n    }\n  }\n\n  /**\n   * Remove bar\n   *\n   * @param {string} position - Bar position to remove\n   * @param {boolean} removeElement - Remove DOM element?\n   * @returns {void}\n   */\n  removeBar (position = null, removeElement = true) {\n    try {\n      // If this bar is currently open, close it first\n      if (this.currentOpenBar && this.currentOpenBar.position === position) {\n        this.close()\n      }\n\n      // Validate position\n      if (!this.isValidPosition(position)) throw 'Invalid bar position \\'' + position + '\\'. Use one of the following values: ' + this.validBarPositions.join(', ')\n      if (!this.bars[position]) throw 'Bar with position \\'' + position + '\\' doesn\\'t exist'\n\n      if (removeElement === true) {\n        this.mainWrap.removeChild(this.bars[position].element)\n      }\n\n      delete this.bars[position]\n\n      this.debug('Removed bar with position \\'' + position + '\\'')\n    } catch (error) {\n      this.logError(error)\n    }\n  }\n\n  /**\n   * Open off-canvas bar\n   *\n   * @param {string} position - Bar position\n   * @param {object} button - Button which was used to run this method\n   * @returns {object} Opened bar instance\n   */\n  open (position = '', button = null) {\n    try {\n      // Validate position\n      if (!this.isValidPosition(position)) throw 'Invalid bar position \\'' + position + '\\'. Use one of the following values: ' + this.validBarPositions.join(', ')\n\n      // Get bar instance\n      const bar = this.bars[position]\n\n      if (!bar) throw 'Bar with position \\'' + position + '\\' is not defined.'\n\n      // Close other bars\n      if (this.currentOpenBar) {\n        this.close(false)\n      } else if (this.options.trapFocus === true) {\n        this.disableFocus(this.contentWrap)\n      }\n\n      this.debug('Opening bar \\'' + position + '\\'')\n\n      // Mark this bar as open\n      this.currentOpenBar = bar\n      bar.element.classList.add('bartender-bar--open')\n\n      // Scroll to top\n      if (this.options.scrollTop) {\n        bar.element.scrollTop = 0\n      }\n\n      // Focus on bar\n      this.enableFocus(bar.element)\n      bar.element.focus()\n\n      // Push elements\n      this.setPush()\n\n      // Remember the button which was used to open the bar\n      this.previousOpenButton = button\n\n      // Set ARIA attributes of the button\n      if (button) button.setAttribute('aria-expanded', true)\n\n      // Show overlay\n      this.showOverlay()\n\n      // Add class to the main element\n      this.mainWrap.classList.add(this.options.openClass)\n\n      // Dispatch event\n      this.mainWrap.dispatchEvent(new CustomEvent('bartender-open', {\n        bubbles: true,\n        detail: {\n          bar: bar,\n          button: button,\n        },\n      }))\n\n      return bar\n    } catch (error) {\n      this.logError(error)\n    }\n  }\n\n  /**\n   * Toggle off-canvas bar\n   *\n   * @param {string} position - Bar position\n   * @param {object} button - Button which was used to run this method\n   * @returns {object} Toggled bar instance\n   */\n  toggle (position = null, button = null) {\n    try {\n      if (!this.isValidPosition(position)) throw 'Invalid bar position \\'' + position + '\\'. Use one of the following values: ' + this.validBarPositions.join(', ')\n\n      if (this.currentOpenBar && this.currentOpenBar.position == position) {\n        return this.close()\n      } else {\n        this.close()\n        return this.open(position, button)\n      }\n    } catch (error) {\n      this.logError(error)\n    }\n  }\n\n  /**\n   * Close any open off-canvas bar\n   *\n   * @param {boolean} enableFocusOfContentWrap - Enable focus of content wrap\n   * @returns {object} Closed bar\n   */\n  close (enableFocusOfContentWrap = true) {\n    try {\n      if (!this.currentOpenBar) return\n\n      let bar = this.bars[this.currentOpenBar.position]\n\n      this.debug('Closing bar \\'' + bar.position + '\\'')\n\n      // Dispatch event\n      this.mainWrap.dispatchEvent(new CustomEvent('bartender-close', {\n        bubbles: true,\n        detail: {\n          bar: bar,\n        },\n      }))\n\n      // Hide overlay\n      this.hideOverlay()\n\n      // Remove transform from wrapper element\n      this.contentWrap.style.removeProperty('transform')\n\n      // Remove transforms from pushable elements\n      for (let i = 0; i < this.pushElements.length; i++) {\n        this.pushElements[i].style.removeProperty('transform')\n      }\n\n      // Disable focus on bar element\n      this.disableFocus(bar.element)\n\n      // Enable focus on content element\n      if (this.options.trapFocus === true && enableFocusOfContentWrap === true) this.enableFocus(this.contentWrap)\n\n      // Close the bar\n      bar.element.classList.remove('bartender-bar--open')\n      this.currentOpenBar = null\n\n      // Restore scrolling to the main wrap\n      this.mainWrap.style.removeProperty('overflow')\n\n      // Remove class from the main wrap\n      this.mainWrap.classList.remove(this.options.openClass)\n\n      // Focus open button which was used to open the bar\n      if (this.previousOpenButton && this.previousOpenButton.getAttribute('tabindex') >= 0) {\n        this.previousOpenButton.focus()\n        this.previousOpenButton.setAttribute('aria-expanded', 'false')\n        this.previousOpenButton = null\n      } else if (enableFocusOfContentWrap === true) {\n        // Bar was closed using keyboard or API. Focus on content wrapper instead.\n        this.contentWrap.focus()\n      }\n\n      return bar\n    } catch (error) {\n      this.logError(error)\n    }\n  }\n\n  /**\n   * Set transforms for pushable elements\n   *\n   * @returns {void}\n   */\n  setPush () {\n    if (!this.currentOpenBar || !this.currentOpenBar.mode) return\n\n    let transform = null\n\n    // Hide overflow of main wrapper\n    // This has to be done first in order to get correct width/height\n    this.mainWrap.style.overflow = 'hidden'\n\n    switch (this.currentOpenBar.position) {\n      case 'left':\n        transform = 'translateX(' + this.currentOpenBar.element.offsetWidth + 'px)'\n        break\n\n      case 'right':\n        transform = 'translateX(-' + this.currentOpenBar.element.offsetWidth + 'px)'\n        break\n\n      case 'top':\n        transform = 'translateY(' + this.currentOpenBar.element.offsetHeight + 'px)'\n        break\n\n      case 'bottom':\n        transform = 'translateY(-' + this.currentOpenBar.element.offsetHeight + 'px)'\n        break\n    }\n\n    if ([\n      'push',\n      'reveal',\n    ].indexOf(this.currentOpenBar.mode) >= 0) {\n      // Transform content wrapper\n      this.contentWrap.style.transform = transform\n    }\n\n    // Transform other pushable elements\n    for (let i = 0; i < this.pushElements.length; i++) {\n      this.pushElements[i].style.transform = transform\n    }\n  }\n\n  /**\n   * Show shading overlay\n   *\n   * @returns {void}\n   */\n  showOverlay () {\n    if (!this.overlay) return\n    if (this.overlay.classList.contains('bartender-overlay--visible')) return\n\n    this.overlay.classList.add('bartender-overlay--visible')\n  }\n\n  /**\n   * Hide shading overlay\n   *\n   * @returns {void}\n   */\n  hideOverlay () {\n    if (!this.overlay) return\n    if (!this.overlay.classList.contains('bartender-overlay--visible')) return\n\n    this.overlay.classList.remove('bartender-overlay--visible')\n  }\n}\n"],"file":"bartender.module.js"}